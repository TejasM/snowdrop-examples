<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "guide.ent">
%BOOK_ENTITIES;
]>
<chapter id="chap-guide-usecases">
  <title>Using JBoss and Spring together</title>

  <para>This chapter will describe the various Spring and JBoss integration
  use cases covered by the application and will describe how are they
  implemented in the various application modules.</para>

  <para>As a Spring application that consists of multiple modules, our
  strategy is to provide fragments of Spring configuration in each artifact
  produced by a module, leaving to the upper layer components to aggregate
  them. This strategy has multiple benefits: for one, it allows to separate
  concerns between components - the Spring wiring of certain components is
  left at the level where the components are defined, so that it can be
  changed easily if the implementations change.</para>

  <section>
    <title>A list of the Spring integration use cases</title>

    <para>The Sportsclub application covers a number of JBoss and Spring
    integration use cases. The scenarios selected for this example are
    focusing on using the Java EE 5 services provided by JBoss AS in Spring
    applications.</para>

    <para></para>
  </section>

  <section>
    <title>The domain model</title>

    <para>The sportsclub-domain module is the only module of the application
    that does not integrate with Spring directly. However, it is used further
    in the application as it provides:</para>

    <para><itemizedlist>
        <listitem>
          <para>the entities that the application will interact with;</para>
        </listitem>

        <listitem>
          <para>the repository interfaces that provide persistence services
          for the application</para>
        </listitem>
      </itemizedlist>A relevant note regarding the domain module is the use of
    the term "repository" for the components that are used for retrieving
    objects from persistence and saving them. The intent behind that is to
    indicate that the design of the application is emulating the concepts
    behind Domain-Driven Design, where the objects that are used for providing
    the persistence and entity lookup functions are part of the domain, rather
    than simple persistence implementation strategies (as it is the case with
    the fairly similar Data Access Objects).</para>
  </section>

  <section>
    <title>Persistence implementation: JPA and Hibernate</title>

    <para>The persistence modules: sportsclub-hibernate-dao and
    sportsclub-jpa-dao are alternative implementations of the application's
    persistence strategy. This means that each module will provide:</para>

    <para><itemizedlist>
        <listitem>
          <para>implementations for the repository interfaces defined in the
          sportsclub-domain module;</para>
        </listitem>

        <listitem>
          <para>Spring context definition fragments that can be reused
          elsewhere in the application</para>
        </listitem>
      </itemizedlist>Effectively, the Spring configuration fragments will
    expose a bean implementation for each repository interface defined in the
    model. This means that the implementations can be swapped at build-time
    without any change in the business layer. This is the basis for the build
    process creating two different builds, each based on a different
    persistence implementation - including a different repository
    implementation jar and leaving everyting else in the component stack
    unchanged.</para>

    <para>Each module produces a set of beans that can be injected further
    into the business services of the application.</para>

    <section>
      <title>The Hibernate implementation</title>

      <para>The Hibernate-based repository implementation defines a generic
      superclass defining all the common repository operations that that
      repository implementations will parametrize by specifying the entity
      type and primary key type.<informalexample>
          <para><programlisting lang="JAVA" language="JAVA">public abstract class HibernateRepository&lt;T, I extends Serializable&gt; implements Repository&lt;T, I&gt;
{
   protected SessionFactory sessionFactory;

   Class&lt;T&gt; clazz;

   public HibernateRepository(Class&lt;T&gt; clazz)
   {
      this.clazz = clazz;
   }

   public void setSessionFactory(SessionFactory sessionFactory)
   {
      this.sessionFactory = sessionFactory;
   }

   protected Session getCurrentSession()
   {
      return this.sessionFactory.getCurrentSession();
   }
   
   public T findById(I id)
   {
      return (T)getCurrentSession().get(clazz, id);
   }

   public void save(T object)
   {
      getCurrentSession().saveOrUpdate(object);
   }

   public void delete(T object)
   {
      getCurrentSession().delete(object);
   }

   public List&lt;T&gt; findAll()
   {
      return getCurrentSession().createCriteria(clazz).list();
   }


   public long countAll()
   {
      return (Integer)getCurrentSession().createCriteria(clazz).setProjection(Projections.count("id")).uniqueResult();
   }

   public Criteria applyRange(Criteria criteria, Range range)
   {
      return criteria.setFirstResult(range.getMinIndex()).setMaxResults(range.length());
   }
}</programlisting>It is important to notice that this implementation and its
          subclasses are not Spring-based.</para>
        </informalexample></para>

      <para><informalexample>
          <para>The only Spring-related component of this module is the
          configuration which consists of two files:</para>

          <para><itemizedlist>
              <listitem>
                <para>spring-hibernate-dao/src/main/resources/dao-context.xml
                - which contains the Spring bean definitions for the
                repository implementations, the Spring-based SessionFactory
                definition (a LocalSessionFactoryBean) and the wiring of
                SessionFactories into Spring beans</para>
              </listitem>

              <listitem>
                <para>spring-hibernate-dao/src/main/resources/infrastructure.xml
                - which contains the definitions for the
                infrastructure-related Spring beans, namely: the data source
                to be used for the Hibernate SessionFactory and the
                transaction manager</para>
              </listitem>
            </itemizedlist>Separating the infrastructure context definition
          file from the rest of the bean definitions allows to swap the
          infrastructure definition for unit testing. For example, the
          Hibernate SessionFactory is configured to use JTA transactions, and
          allows the Session to shared with a layer of EJBs that delegate to
          it.</para>
        </informalexample></para>
    </section>

    <section>
      <title>The JPA implementation</title>

      <para>The JPA implementation is, in many respects, very similar to the
      Hibernate implementation, in that it provides a parametrized superclass
      that is Spring-agnostic. Besides the fact that it is using the JPA API -
      for example an EntityManager instead of the SessionFactory, the JPA
      Persistence Unit (and subsequent EntityManager) are created by the
      application server and not created by Spring (the EntityManager is
      injected by Spring, but acquired from JNDI). The persistence unit is
      deployed from within the JPA repository jar, in order to allow the
      spring-domain jar to be deployed in non-JPA scenarios (e.g. Hibernate)
      without triggering a persistence unit deployment.</para>

      <para>The Spring application context configuration fragments are very
      similar to the ones encountered in the Hibernate module:</para>

      <para><itemizedlist>
          <listitem>
            <para>spring-jpa-dao/src/main/resources/dao-context.xml - contains
            the Spring bean definitions for the repository implementations,
            assuming an EntityManager bean to be defined in the global
            application context definition</para>
          </listitem>

          <listitem>
            <para>spring-jpa-dao/src/main/resources/infrastructure.xml - which
            contains the definitions for the infrastructure-related Spring
            beans, namely: the data source to be used for the Hibernate
            SessionFactory, and the transaction manager</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Unit testing the repositories</title>

      <para>With the infrastructure so tied to the Application Server, how can
      we test the repositories in isolation, making sure that they work
      properly, before we even consider integrating them with the rest of the
      application?</para>

      <para>If at deployment time we will use the JBoss Application Server
      provided services, for testing we are going to use an embedded database,
      and Spring's ability to create LocalSessionFactories,
      LocalEntityManagerFactories and its local transaction management
      abilities.</para>

      <para>For this, we are going to use the spring-test-infrastructure
      module, which is a test-scoped dependency. This module contains the
      modules used for setting up an embedded database (producing a DataSource
      that can be injected into the LocalSessionFactoryBean and
      LocalContainerEntityManagerFactoryBean, respectively). The localized
      SessionFactory and EntityManager definitions are located in the
      spring-hibernate-dao and spring-jpa-dao modules, respectively.</para>

      <para>The unit tests that are located in the respective modules will use
      the local infrastructure files and the dao-context.xml files, as in the
      following example:</para>

      <informalexample>
        <para><programlisting lang="JAVA">@ContextConfiguration(locations = {"classpath:test-db-infrastructure.xml",
                                   "classpath:TEST-jpa-infrastructure.xml",
                                   "classpath:dao-context.xml"})
@RunWith(SpringJUnit4ClassRunner.class)
public class TestJpaAccountRepository
{
   /* */
}
</programlisting>This configuration reuses the 'application-specific' context
        configuration fragment, as well as two specific context configuration
        fragments to create an Spring context in isolation. Thus, the
        functionality provided by the repositories can be tested outside the
        running application.</para>
      </informalexample>
    </section>
  </section>

  <section>
    <title>Service Layer</title>

    <para>On top of the domain and persistence layer sits the service layer of
    the application. Its role is to co-ordinate the domain objects and
    repositories in order to perform higher level operations. This is also the
    layer which provides transaction demarcation.</para>

    <para>In the Sportsclub application, there are two variants of
    implementing the service layer:</para>

    <itemizedlist>
      <listitem>
        <para>using Spring (Reservations, parts of Invoicing)</para>
      </listitem>

      <listitem>
        <para>using EJB (Subscriptions, Invoicing)</para>
      </listitem>
    </itemizedlist>

    <para><note>
        <para>It is possible to define transactions at the repository level,
        thus avoiding another indirection to the persistence layer for simple
        persistence operations (finding an object, persisting an
        object).</para>
      </note></para>

    <section>
      <title>The Spring-based service layer</title>

      <para>The Spring-based service layer exposes a number of service beans
      that can be consumed by the UI. The service beans are injected with the
      beans defined in the persistence layer.</para>
    </section>

    <section>
      <title>The EJB service layer</title>

      <para>A common scenario in Spring/EJB integration is the wrapping of
      Spring Beans in EJBs. This is very often done in order to get advantage
      of the services provided by the EJB container (security, declarative
      transaction management), while keeping some of the objects they
      collaborate with as simple POJOs. In this scenario, the EJBs form the
      outermost layer of the business logic, the one that is exposed to the
      rest of the application (UI). In this scenario, the EJB services are
      injected with the Spring-based repositories.</para>

      <para>JBoss has its own native support for Spring/EJB integration, in
      the form of the Spring Deployer and special annotations for injection of
      Spring beans into EJBs.</para>

      <simplesect>
        <title>The Spring Deployer</title>

        <para>The Spring Deployer is a JBoss-specific deployer that can be
        used to bootstrap a Spring ApplicationContext and register it into
        JNDI. The configuration files for bootstrapping the application
        context are defined at the EAR level, and the Spring
        ApplicationContext is shared to all the components. The definition
        file is simple, and just imports the contexts defined in the JPA
        jars.</para>

        <informalexample>
          <para><programlisting>&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;description&gt;BeanFactory=(SpringDao)&lt;/description&gt;

    &lt;import resource="classpath*:dao-context.xml"/&gt;
    &lt;import resource="classpath*:infrastructure.xml"/&gt;


&lt;/beans&gt;</programlisting></para>
        </informalexample>
      </simplesect>

      <simplesect>
        <title>Injection into EJBs</title>

        <para>Once the ApplicationContext is created, the beans defined there
        can be injected into EJBs. So, in this case, the Spring repositories
        will be injected into EJBs as follows:</para>

        <para><informalexample>
            <para><programlisting>@Stateless
@Interceptors(SpringLifecycleInterceptor.class)
@LocalBinding(jndiBinding="sportsclub/BillingService")
public class BillingServiceImpl implements BillingService
{
   @Spring(bean = "invoiceRepository", jndiName = "SpringDao")
   private InvoiceRepository invoiceRepository;

   /* rest of the class definition ommitted */
}</programlisting></para>
          </informalexample>The injection task is undertaken by the
        SpringLifecycleInterceptor. Once it encounters a field or setter
        annotated with @Spring, it will look for the JNDI-bound application
        context and inject the corresponding Spring bean.</para>
      </simplesect>
    </section>
  </section>

  <section>
    <title>Presentation Layer</title>

    <para>The three web applications which compose the Sportsclub package
    illustrate different ways of integrating Spring and Java EE technologies
    in the presentation layer:</para>

    <para><itemizedlist>
        <listitem>
          <para>JSF/EJB with an underlying Spring layer (Subscriptions)</para>
        </listitem>

        <listitem>
          <para>JSF/Spring (Reservations)</para>
        </listitem>

        <listitem>
          <para>Spring MVC/EJB (Invoicing)</para>
        </listitem>
      </itemizedlist></para>

    <section>
      <title>Subscriptions: JSF/EJB over a Spring layer</title>

      <para>The Subscriptions application uses Richfaces and JSF for the
      presentation layer and EJB for the business layer, so this part of the
      application is not Spring-related. The only Spring-related feature at
      this level is the fact that the repositories used by the EJBs are Spring
      beans.</para>

      <para>Although this is somewhat out of the Spring topic, it is worth
      mentioning for the benefit of the reader that we recommend using Seam
      for building applications that integrate JSF and EJB in Java EE 5. This
      type of integration is, however, beyond the scope of the current demo
      application, so we are mentioning it here, although this example is not
      demonstrating it.</para>
    </section>

    <section>
      <title>Reservations</title>

      <para>The Reservations application is an example of using Spring in an
      application that uses Richfaces and JSF. Here, Spring beans are used as
      business services for the application, as well as backing beans for the
      JSF pages. In the latter case, Spring beans replace the managed beans
      and other web artifacts used by JSF.</para>

      <para>The Spring application context is bootstrapped by the
      ContextLoaderListener defined in /WEB-INF/web.xml. The Spring
      configuration file in use is /WEB-INF/spring-beans.xml, which:</para>

      <itemizedlist>
        <listitem>
          <para>imports the context definition fragments included in the other
          JARs of the application (i.e. the JARs that contain the business
          logic, defined at 4.1)</para>
        </listitem>

        <listitem>
          <para>defines a number of Spring beans that are used directly in the
          web tier by the JSF pages or by the Richfaces components;</para>
        </listitem>
      </itemizedlist>

      <para>The Spring configuration file imports the Spring business beans
      and infrastructure definitions as follows:</para>

      <informalexample>
        <para><programlisting>&lt;import resource="classpath*:reservations-service.xml"/&gt;

&lt;import resource="classpath*:infrastructure.xml"/&gt;</programlisting></para>

        <para>The following bean is used for backing JSF pages. Please note
        that Spring beans defined in the web layer may use scopes, and a
        significant number of the Spring beans used in Reservations
        application are session-scoped. Spring provides a request scope as
        well.</para>

        <programlisting>&lt;bean id="reservationCreate" class="org.jboss.snowdrop.samples.sportsclub.jsf.beans.ReservationCreate" scope="session" init-method="init"&gt;
        &lt;property name="reservationService" ref="reservationService"/&gt;
        &lt;property name="accountService" ref="accountService"/&gt;
        &lt;property name="accountFilter" ref="accountFilterCreate"/&gt;
        &lt;property name="equipmentFilter" ref="equipmentFilterCreate"/&gt;
&lt;/bean&gt;</programlisting>

        <informalexample>
          <para>P</para>
        </informalexample>
      </informalexample>
    </section>
  </section>

  <section>
    <title>Other Enterprise Integration features</title>

    <para></para>
  </section>
</chapter>
