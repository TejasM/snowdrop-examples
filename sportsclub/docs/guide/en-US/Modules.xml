<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "guide.ent">
%BOOK_ENTITIES;
]>
<chapter id="chap-guide-usecases">
  <title>Using JBoss and Spring together</title>

  <para>This chapter will describe the various Spring and JBoss integration
  use cases covered by the application and will describe how are they
  implemented in the various application modules.</para>

  <para>As a Spring application that consists of multiple modules, our
  strategy is to provide fragments of Spring configuration in each artifact
  produced by a module, leaving to the upper layer components to aggregate
  them. This strategy has multiple benefits: for one, it allows to separate
  concerns between components - the Spring wiring of certain components is
  left at the level where the components are defined, so that it can be
  changed easily if the implementations change.</para>

  <section>
    <title>A list of the Spring integration use cases</title>

    <para>The Sportsclub application covers a number of JBoss and Spring
    integration use cases. The scenarios selected for this example are
    focusing on using the Java EE 5 services provided by JBoss AS in Spring
    applications.</para>

    <para></para>
  </section>

  <section>
    <title>The domain model</title>

    <para>The sportsclub-domain module is the only module of the application
    that does not integrate with Spring directly. However, it is used further
    in the application as it provides:</para>

    <para><itemizedlist>
        <listitem>
          <para>the entities that the application will interact with;</para>
        </listitem>

        <listitem>
          <para>the repository interfaces that provide persistence services
          for the application</para>
        </listitem>
      </itemizedlist>A relevant note regarding the domain module is the use of
    the term "repository" for the components that are used for retrieving
    objects from persistence and saving them. The intent behind that is to
    indicate that the design of the application is emulating the concepts
    behind Domain-Driven Design, where the objects that are used for providing
    the persistence and entity lookup functions are part of the domain, rather
    than simple persistence implementation strategies (as it is the case with
    the fairly similar Data Access Objects).</para>
  </section>

  <section>
    <title>Persistence implementation: JPA and Hibernate</title>

    <para>The persistence modules: sportsclub-hibernate-dao and
    sportsclub-jpa-dao are alternative implementations of the application's
    persistence strategy. This means that each module will provide:</para>

    <para><itemizedlist>
        <listitem>
          <para>implementations for the repository interfaces defined in the
          sportsclub-domain module;</para>
        </listitem>

        <listitem>
          <para>Spring context definition fragments that can be reused
          elsewhere in the application</para>
        </listitem>
      </itemizedlist>Effectively, the Spring configuration fragments will
    expose a bean implementation for each repository interface defined in the
    model. This means that the implementations can be swapped at build-time
    without any change in the business layer. This is the basis for the build
    process creating two different builds, each based on a different
    persistence implementation - including a different repository
    implementation jar and leaving everyting else in the component stack
    unchanged.</para>

    <para>Each module produces a set of beans that can be injected further
    into the business services of the application.</para>

    <section>
      <title>The Hibernate implementation</title>

      <para>The Hibernate-based repository implementation defines a generic
      superclass defining all the common repository operations that that
      repository implementations will parametrize by specifying the entity
      type and primary key type.<informalexample>
          <para><programlisting lang="JAVA" language="JAVA">public abstract class HibernateRepository&lt;T, I extends Serializable&gt; implements Repository&lt;T, I&gt;
{
   protected SessionFactory sessionFactory;

   Class&lt;T&gt; clazz;

   public HibernateRepository(Class&lt;T&gt; clazz)
   {
      this.clazz = clazz;
   }

   public void setSessionFactory(SessionFactory sessionFactory)
   {
      this.sessionFactory = sessionFactory;
   }

   protected Session getCurrentSession()
   {
      return this.sessionFactory.getCurrentSession();
   }
   
   public T findById(I id)
   {
      return (T)getCurrentSession().get(clazz, id);
   }

   public void save(T object)
   {
      getCurrentSession().saveOrUpdate(object);
   }

   public void delete(T object)
   {
      getCurrentSession().delete(object);
   }

   public List&lt;T&gt; findAll()
   {
      return getCurrentSession().createCriteria(clazz).list();
   }


   public long countAll()
   {
      return (Integer)getCurrentSession().createCriteria(clazz).setProjection(Projections.count("id")).uniqueResult();
   }

   public Criteria applyRange(Criteria criteria, Range range)
   {
      return criteria.setFirstResult(range.getMinIndex()).setMaxResults(range.length());
   }
}</programlisting>It is important to notice that this implementation and its
          subclasses are not Spring-based.</para>
        </informalexample></para>

      <para><informalexample>
          <para>The only Spring-related component of this module is the
          configuration which consists of two files:</para>

          <para><itemizedlist>
              <listitem>
                <para>spring-hibernate-dao/src/main/resources/dao-context.xml
                - which contains the Spring bean definitions for the
                repository implementations, the Spring-based SessionFactory
                definition (a LocalSessionFactoryBean) and the wiring of
                SessionFactories into Spring beans</para>
              </listitem>

              <listitem>
                <para>spring-hibernate-dao/src/main/resources/infrastructure.xml
                - which contains the definitions for the
                infrastructure-related Spring beans, namely: the data source
                to be used for the Hibernate SessionFactory and the
                transaction manager</para>
              </listitem>
            </itemizedlist>Separating the infrastructure context definition
          file from the rest of the bean definitions allows to swap the
          infrastructure definition for unit testing. For example, the
          Hibernate SessionFactory is configured to use JTA transactions, and
          allows the Session to shared with a layer of EJBs that delegate to
          it.</para>
        </informalexample></para>
    </section>

    <section>
      <title>The JPA implementation</title>

      <para>The JPA implementation is, in many respects, very similar to the
      Hibernate implementation, in that it provides a parametrized superclass
      that is Spring-agnostic. Besides the fact that it is using the JPA API -
      for example an EntityManager instead of the SessionFactory, the JPA
      Persistence Unit (and subsequent EntityManager) are created by the
      application server and not created by Spring (the EntityManager is
      injected by Spring, but acquired from JNDI). The persistence unit is
      deployed from within </para>

      <para>The Spring application context configuration fragments are very
      similar to the ones encountered in the Hibernate module:</para>

      <para><itemizedlist>
          <listitem>
            <para>spring-jpa-dao/src/main/resources/dao-context.xml - contains
            the Spring bean definitions for the repository implementations,
            assuming an EntityManager bean to be defined in the global
            application context definition</para>
          </listitem>

          <listitem>
            <para>spring-jpa-dao/src/main/resources/infrastructure.xml - which
            contains the definitions for the infrastructure-related Spring
            beans, namely: the data source to be used for the Hibernate
            SessionFactory and the transaction manager</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Unit testing the repositories</title>

      <para>With the infrastructure so tied to the Application Server, how can
      we test the repositories in isolation, making sure that they work
      properly, before we even consider integrating them with the rest of the
      application?</para>

      <para>If at deployment time we will use the JBoss Application Server
      provided services, for testing we are going to use an embedded database,
      and Spring's ability to create LocalSessionFactories,
      LocalEntityManagerFactories and its local transaction management
      abilities.</para>

      <para>For this, we are going to use the spring-test-infrastructure
      module, which is a test-scoped dependency. This module contains the
      modules used for setting up an embedded database (producing a DataSource
      that can be injected into the LocalSessionFactoryBean and
      LocalContainerEntityManagerFactoryBean, respectively). The localized
      SessionFactory and EntityManager definitions are located in the
      spring-hibernate-dao and spring-jpa-dao modules, respectively.</para>

      <para>The unit tests that are located in the respective modules will use
      the local infrastructure files and the dao-context.xml files, as in the
      following example:</para>

      <informalexample>
        <para><programlisting lang="JAVA">@ContextConfiguration(locations = {"classpath:test-db-infrastructure.xml",
                                   "classpath:TEST-jpa-infrastructure.xml",
                                   "classpath:dao-context.xml"})
@RunWith(SpringJUnit4ClassRunner.class)
public class TestJpaAccountRepository
{
   /* */
}
</programlisting>This configuration reuses the 'application-specific' context
        configuration fragment, as well as two specific context configuration
        fragments to create an Spring context in isolation. Thus, the
        functionality provided by the repositories can be tested outside the
        running application.</para>
      </informalexample>
    </section>
  </section>

  <section>
    <title>Service Layer</title>

    <para>On top of the domain and persistence layer sits the service layer of
    the application. Its role is to co-ordinate the domain objects and
    repositories in order to perform higher level operations. This is also the
    layer which provides transaction demarcation.</para>

    <para>In the Sportsclub application, there are two variants of
    implementing the service layer:</para>

    <itemizedlist>
      <listitem>
        <para>using Spring (Reservations, parts of Invoicing)</para>
      </listitem>

      <listitem>
        <para>using EJB (Subscriptions, Invoicing)</para>
      </listitem>
    </itemizedlist>

    <para><note>
        <para>It is possible to define transactions at the repository level,
        thus avoiding another indirection to the persistence layer for simple
        persistence operations (finding an object, persisting an
        object).</para>
      </note></para>

    <section>
      <title>The Spring-based service layer</title>

      <para>The Spring-based service layer exposes a number of service beans
      that can be consumed by the UI. The service beans are injected with the
      beans defined in the persistence layer.</para>
    </section>

    <section>
      <title>The EJB service layer</title>

      <para>A common scenario in Spring/EJB integration is the wrapping of
      Spring Beans in EJBs. This is very often done in order to get advantage
      of the services provided by the EJB container (security, declarative
      transaction management), while keeping some of the objects they
      collaborate with as simple POJOs. In this scenario, the EJBs form the
      outermost layer of the business logic, the one that is exposed to the
      rest of the application (UI). In this scenario, the EJB services are
      injected with the Spring0-based repositories.</para>

      <para>JBoss has its own native support for this, in the form of the
      Spring Deployer and special annotations for injection</para>
    </section>
  </section>
</chapter>
