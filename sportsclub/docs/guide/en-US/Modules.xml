<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "guide.ent">
%BOOK_ENTITIES;
]>
<chapter id="chap-guide-modules">
  <title>Using JBoss and Spring together</title>

  <para>This chapter will describe the various Spring and JBoss integration
  use cases covered by the application and will describe how are they
  implemented in the various application modules.</para>

  <para>As a Spring application that consists of multiple modules, our
  strategy is to provide fragments of Spring configuration in each artifact
  produced by a module, leaving to the upper layer components to aggregate
  them. This strategy has multiple benefits: for one, it allows to separate
  concerns between components - the Spring wiring of certain components is
  left at the level where the components are defined, so that it can be
  changed easily if the implementations change.</para>

  <section>
    <title>A look at the JBoss/Spring integration use cases</title>

    <para>The Sportsclub application covers a number of JBoss and Spring
    integration use cases. The scenarios selected for this example are
    focusing on using the Java EE 5 services provided by JBoss AS in Spring
    applications.</para>

    <para>The use cases can be grouped in categories as follows:<table>
        <title>Use case list overview</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Category</entry>

              <entry align="center">Use case</entry>

              <entry align="center">How does this involve JBoss AS</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Persistence</entry>

              <entry>Spring/Hibernate integration</entry>

              <entry>The application is using a Spring-configured Hibernate
              SessionFactory using JTA transaction management and bound to
              JTA. The Hibernate library being used is the one provided by
              JBoss AS.</entry>
            </row>

            <row>
              <entry></entry>

              <entry>Spring/JPA integration</entry>

              <entry>The Persistence Unit is deployed by JBoss and retrieved
              from JNDI to be injected into Spring beans. PersistenceContext
              is shared with surrounding EJBs (if any)</entry>
            </row>

            <row>
              <entry>Testing</entry>

              <entry>Unit-testing components that have managed infrastructure
              dependencies</entry>

              <entry>The DataSource and EntityManager are managed by JBoss and
              acquired from JNDI by Spring when the application is running. In
              the case of JBoss, developers can test their code in isolation
              using Spring-specific replacements that 'simulate' the JBoss
              environment.</entry>
            </row>

            <row>
              <entry>Business Logic</entry>

              <entry>Spring-based service beans</entry>

              <entry>The business services are Spring-managed and wrapped into
              transactions managed by Spring's interceptors. The
              TransactionManager in use is the JTATransactionManager using
              JBoss Transactions provided in JBoss AS.</entry>
            </row>

            <row>
              <entry></entry>

              <entry>EJBs injected with Spring Beans</entry>

              <entry>The application uses JBoss-deployed EJBs which are
              injected with Spring beans acquired from an application context
              bootstrapped by the Spring Deployer. Transactions are managed by
              EJBs.</entry>
            </row>

            <row>
              <entry>User Interface</entry>

              <entry>JSF/Richfaces and Spring integration</entry>

              <entry>The application uses the JBoss AS-provided JSF support,
              and Richfaces components. The business services and UI-backing
              instances are Spring beans.</entry>
            </row>

            <row>
              <entry></entry>

              <entry>Spring MVC and EJB integration</entry>

              <entry>The application uses Spring MVC and the business logic is
              implemented using JBoss-deployed EJBs, which are injected into
              the Spring controllers.</entry>
            </row>

            <row>
              <entry>JMS/JCA integration</entry>

              <entry>JMS/Spring integration using JCA</entry>

              <entry>Spring-configured message listeners are used for
              processing JMS messages from JBoss AS-managed destinations. The
              application uses the Spring /JCA integration for receiving
              messages.</entry>
            </row>

            <row>
              <entry>Aspect-oriented programming</entry>

              <entry>Spring-based weaving of POJO aspects</entry>

              <entry>This use case does not have any JBoss AS-specific
              functionality.</entry>
            </row>

            <row>
              <entry>JMX</entry>

              <entry>Spring beans are exposed as JMX beans</entry>

              <entry>The JBoss AS MBean Server is used for registering the
              Spring-exported JMX beans. Consequently, the Spring beans can be
              managed from the JBoss AS Administration Console.</entry>
            </row>

            <row>
              <entry>Web Services</entry>

              <entry>JAX-WS defined web-services are injected with Spring
              beans</entry>

              <entry>The application uses JBoss AS' support for JAX-WS through
              JBoss WS, but also Spring to define the underlying business
              logic, which is injected into the JBoss WS-deployed
              services.</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>
  </section>

  <section>
    <title>The domain model</title>

    <para>The sportsclub-domain module is the only module of the application
    that does not integrate with Spring directly. However, it is used further
    in the application as it provides:</para>

    <para><itemizedlist>
        <listitem>
          <para>the entities that the application will interact with;</para>
        </listitem>

        <listitem>
          <para>the repository interfaces that provide persistence services
          for the application</para>
        </listitem>
      </itemizedlist>A relevant note regarding the domain module is the use of
    the term "repository" for the components that are used for retrieving
    objects from persistence and saving them. The intent behind that is to
    indicate that the design of the application is emulating the concepts
    behind Domain-Driven Design, where the objects that are used for providing
    the persistence and entity lookup functions are part of the domain, rather
    than simple persistence implementation strategies (as it is the case with
    the fairly similar Data Access Objects).</para>
  </section>

  <section>
    <title>Persistence implementation: JPA and Hibernate</title>

    <para>The persistence modules: sportsclub-hibernate-dao and
    sportsclub-jpa-dao are alternative implementations of the application's
    persistence strategy. This means that each module will provide:</para>

    <para><itemizedlist>
        <listitem>
          <para>implementations for the repository interfaces defined in the
          sportsclub-domain module;</para>
        </listitem>

        <listitem>
          <para>Spring context definition fragments that can be reused
          elsewhere in the application</para>
        </listitem>
      </itemizedlist>Effectively, the Spring configuration fragments will
    expose a bean implementation for each repository interface defined in the
    model. This means that the implementations can be swapped at build-time
    without any change in the business layer. This is the basis for the build
    process creating two different builds, each based on a different
    persistence implementation - including a different repository
    implementation jar and leaving everyting else in the component stack
    unchanged.</para>

    <para>Each module produces a set of beans that can be injected further
    into the business services of the application.</para>

    <section>
      <title>The Hibernate implementation</title>

      <para>The Hibernate-based repository implementation defines a generic
      superclass defining all the common repository operations that that
      repository implementations will parametrize by specifying the entity
      type and primary key type.<informalexample>
          <para><programlisting lang="JAVA" language="JAVA">public abstract class HibernateRepository&lt;T, I extends Serializable&gt; implements Repository&lt;T, I&gt;
{
   protected SessionFactory sessionFactory;

   Class&lt;T&gt; clazz;

   public HibernateRepository(Class&lt;T&gt; clazz)
   {
      this.clazz = clazz;
   }

   public void setSessionFactory(SessionFactory sessionFactory)
   {
      this.sessionFactory = sessionFactory;
   }

   protected Session getCurrentSession()
   {
      return this.sessionFactory.getCurrentSession();
   }
   
   public T findById(I id)
   {
      return (T)getCurrentSession().get(clazz, id);
   }

   public void save(T object)
   {
      getCurrentSession().saveOrUpdate(object);
   }

   public void delete(T object)
   {
      getCurrentSession().delete(object);
   }

   public List&lt;T&gt; findAll()
   {
      return getCurrentSession().createCriteria(clazz).list();
   }


   public long countAll()
   {
      return (Integer)getCurrentSession().createCriteria(clazz).setProjection(Projections.count("id")).uniqueResult();
   }

   public Criteria applyRange(Criteria criteria, Range range)
   {
      return criteria.setFirstResult(range.getMinIndex()).setMaxResults(range.length());
   }
}</programlisting>It is important to notice that this implementation and its
          subclasses are not Spring-based.</para>
        </informalexample></para>

      <para><informalexample>
          <para>The only Spring-related component of this module is the
          configuration which consists of two files:</para>

          <para><itemizedlist>
              <listitem>
                <para>spring-hibernate-dao/src/main/resources/dao-context.xml
                - which contains the Spring bean definitions for the
                repository implementations, the Spring-based SessionFactory
                definition (a LocalSessionFactoryBean) and the wiring of
                SessionFactories into Spring beans</para>
              </listitem>

              <listitem>
                <para>spring-hibernate-dao/src/main/resources/infrastructure.xml
                - which contains the definitions for the
                infrastructure-related Spring beans, namely: the data source
                to be used for the Hibernate SessionFactory and the
                transaction manager</para>
              </listitem>
            </itemizedlist>Separating the infrastructure context definition
          file from the rest of the bean definitions allows to swap the
          infrastructure definition for unit testing. For example, the
          Hibernate SessionFactory is configured to use JTA transactions, and
          allows the Session to shared with a layer of EJBs that delegate to
          it.</para>
        </informalexample></para>
    </section>

    <section>
      <title>The JPA implementation</title>

      <para>The JPA implementation is, in many respects, very similar to the
      Hibernate implementation, in that it provides a parametrized superclass
      that is Spring-agnostic. Besides the fact that it is using the JPA API -
      for example an EntityManager instead of the SessionFactory, the JPA
      Persistence Unit (and subsequent EntityManager) are created by the
      application server and not created by Spring (the EntityManager is
      injected by Spring, but acquired from JNDI). The persistence unit is
      deployed from within the JPA repository jar, in order to allow the
      spring-domain jar to be deployed in non-JPA scenarios (e.g. Hibernate)
      without triggering a persistence unit deployment.</para>

      <para>The Spring application context configuration fragments are very
      similar to the ones encountered in the Hibernate module:</para>

      <para><itemizedlist>
          <listitem>
            <para>spring-jpa-dao/src/main/resources/dao-context.xml - contains
            the Spring bean definitions for the repository implementations,
            assuming an EntityManager bean to be defined in the global
            application context definition</para>
          </listitem>

          <listitem>
            <para>spring-jpa-dao/src/main/resources/infrastructure.xml - which
            contains the definitions for the infrastructure-related Spring
            beans, namely: the data source to be used for the Hibernate
            SessionFactory, and the transaction manager</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Unit testing the repositories</title>

      <para>With the infrastructure so tied to the Application Server, how can
      we test the repositories in isolation, making sure that they work
      properly, before we even consider integrating them with the rest of the
      application?</para>

      <para>If at deployment time we will use the JBoss Application Server
      provided services, for testing we are going to use an embedded database,
      and Spring's ability to create LocalSessionFactories,
      LocalEntityManagerFactories and its local transaction management
      abilities.</para>

      <para>For this, we are going to use the spring-test-infrastructure
      module, which is a test-scoped dependency. This module contains the
      modules used for setting up an embedded database (producing a DataSource
      that can be injected into the LocalSessionFactoryBean and
      LocalContainerEntityManagerFactoryBean, respectively). The localized
      SessionFactory and EntityManager definitions are located in the
      spring-hibernate-dao and spring-jpa-dao modules, respectively.</para>

      <para>The unit tests that are located in the respective modules will use
      the local infrastructure files and the dao-context.xml files, as in the
      following example:</para>

      <informalexample>
        <para><programlisting lang="JAVA">@ContextConfiguration(locations = {"classpath:test-db-infrastructure.xml",
                                   "classpath:TEST-jpa-infrastructure.xml",
                                   "classpath:dao-context.xml"})
@RunWith(SpringJUnit4ClassRunner.class)
public class TestJpaAccountRepository
{
   /* */
}
</programlisting>This configuration reuses the 'application-specific' context
        configuration fragment, as well as two specific context configuration
        fragments to create an Spring context in isolation. Thus, the
        functionality provided by the repositories can be tested outside the
        running application.</para>
      </informalexample>
    </section>
  </section>

  <section>
    <title>Service Layer</title>

    <para>On top of the domain and persistence layer sits the service layer of
    the application. Its role is to co-ordinate the domain objects and
    repositories in order to perform higher level operations. This is also the
    layer which provides transaction demarcation.</para>

    <para>In the Sportsclub application, there are two variants of
    implementing the service layer:</para>

    <itemizedlist>
      <listitem>
        <para>using Spring (Reservations, parts of Invoicing)</para>
      </listitem>

      <listitem>
        <para>using EJB (Subscriptions, Invoicing)</para>
      </listitem>
    </itemizedlist>

    <para><note>
        <para>It is possible to define transactions at the repository level,
        thus avoiding another indirection to the persistence layer for simple
        persistence operations (finding an object, persisting an
        object).</para>
      </note></para>

    <section>
      <title>The Spring-based service layer</title>

      <para>The Spring-based service layer exposes a number of service beans
      that can be consumed by the UI. The service beans are injected with the
      beans defined in the persistence layer.</para>
    </section>

    <section>
      <title>The EJB service layer</title>

      <para>A common scenario in Spring/EJB integration is the wrapping of
      Spring Beans in EJBs. This is very often done in order to get advantage
      of the services provided by the EJB container (security, declarative
      transaction management), while keeping some of the objects they
      collaborate with as simple POJOs. In this scenario, the EJBs form the
      outermost layer of the business logic, the one that is exposed to the
      rest of the application (UI). In this scenario, the EJB services are
      injected with the Spring-based repositories.</para>

      <para>JBoss has its own native support for Spring/EJB integration, in
      the form of the Spring Deployer and special annotations for injection of
      Spring beans into EJBs.</para>

      <simplesect>
        <title>The Spring Deployer</title>

        <para>The Spring Deployer is a JBoss-specific deployer that can be
        used to bootstrap a Spring ApplicationContext and register it into
        JNDI. The configuration files for bootstrapping the application
        context are defined at the EAR level, and the Spring
        ApplicationContext is shared to all the components. The definition
        file is simple, and just imports the contexts defined in the JPA
        jars.</para>

        <informalexample>
          <para><programlisting>&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;description&gt;BeanFactory=(SpringDao)&lt;/description&gt;

    &lt;import resource="classpath*:dao-context.xml"/&gt;
    &lt;import resource="classpath*:infrastructure.xml"/&gt;


&lt;/beans&gt;</programlisting></para>
        </informalexample>
      </simplesect>

      <simplesect>
        <title>Injection into EJBs</title>

        <para>Once the ApplicationContext is created, the beans defined there
        can be injected into EJBs. So, in this case, the Spring repositories
        will be injected into EJBs as follows:</para>

        <para><informalexample>
            <para><programlisting>@Stateless
@Interceptors(SpringLifecycleInterceptor.class)
@LocalBinding(jndiBinding="sportsclub/BillingService")
public class BillingServiceImpl implements BillingService
{
   @Spring(bean = "invoiceRepository", jndiName = "SpringDao")
   private InvoiceRepository invoiceRepository;

   /* rest of the class definition ommitted */
}</programlisting></para>
          </informalexample>The injection task is undertaken by the
        SpringLifecycleInterceptor. Once it encounters a field or setter
        annotated with @Spring, it will look for the JNDI-bound application
        context and inject the corresponding Spring bean.</para>
      </simplesect>
    </section>
  </section>

  <section>
    <title>Presentation Layer</title>

    <para>The three web applications which compose the Sportsclub package
    illustrate different ways of integrating Spring and Java EE technologies
    in the presentation layer:</para>

    <para><itemizedlist>
        <listitem>
          <para>JSF/EJB with an underlying Spring layer (Subscriptions)</para>
        </listitem>

        <listitem>
          <para>JSF/Spring (Reservations)</para>
        </listitem>

        <listitem>
          <para>Spring MVC/EJB (Invoicing)</para>
        </listitem>
      </itemizedlist></para>

    <section>
      <title>Subscriptions: JSF and Spring</title>

      <para>The Subscriptions application uses Richfaces and JSF for the
      presentation layer and EJB for the business layer, so this part of the
      application is not Spring-related. The only Spring-related feature at
      this level is the fact that the repositories used by the EJBs are Spring
      beans.</para>

      <para>Although this is somewhat out of the Spring topic, it is worth
      mentioning for the benefit of the reader that we recommend using Seam
      for building applications that integrate JSF and EJB in Java EE 5. This
      type of integration is, however, beyond the scope of the current demo
      application, so we are mentioning it here, although this example is not
      demonstrating it.</para>
    </section>

    <section>
      <title>Reservations: JSF/Spring integration</title>

      <para>The Reservations application is an example of using Spring in an
      application that uses Richfaces and JSF. Here, Spring beans are used as
      business services for the application, as well as backing beans for the
      JSF pages. In the latter case, Spring beans replace the managed beans
      and other web artifacts used by JSF.</para>

      <para>The Spring application context is bootstrapped by the
      ContextLoaderListener defined in /WEB-INF/web.xml. The Spring
      configuration file in use is /WEB-INF/spring-beans.xml, which:</para>

      <itemizedlist>
        <listitem>
          <para>imports the context definition fragments included in the other
          JARs of the application (i.e. the JARs that contain the business
          logic, defined at 4.1)</para>
        </listitem>

        <listitem>
          <para>defines a number of Spring beans that are used directly in the
          web tier by the JSF pages or by the Richfaces components;</para>
        </listitem>
      </itemizedlist>

      <para>The Spring configuration file imports the Spring business beans
      and infrastructure definitions as follows:</para>

      <informalexample>
        <para><programlisting>&lt;import resource="classpath*:reservations-service.xml"/&gt;

&lt;import resource="classpath*:infrastructure.xml"/&gt;</programlisting></para>

        <para>The following bean is used for backing JSF pages. Please note
        that Spring beans defined in the web layer may use scopes, and a
        significant number of the Spring beans used in Reservations
        application are session-scoped (like the one in the following
        example). Spring provides a request scope as well, but it is not used
        in this example.</para>

        <programlisting>&lt;bean id="reservationCreate" class="org.jboss.snowdrop.samples.sportsclub.jsf.beans.ReservationCreate" scope="session" init-method="init"&gt;
        &lt;property name="reservationService" ref="reservationService"/&gt;
        &lt;property name="accountService" ref="accountService"/&gt;
        &lt;property name="accountFilter" ref="accountFilterCreate"/&gt;
        &lt;property name="equipmentFilter" ref="equipmentFilterCreate"/&gt;
&lt;/bean&gt;</programlisting>

        <informalexample>
          <para>In order to be make the Spring beans visible to JSF pages, a
          special VariableResolver has to be defined in
          /WEB-INF/faces-config.xml.</para>

          <informalexample>
            <para><programlisting>&lt;application&gt;
  &lt;!-- other definitions --&gt;
  &lt;el-resolver&gt;org.springframework.web.jsf.el.SpringBeanFacesELResolver&lt;/el-resolver&gt;
&lt;/application&gt;</programlisting>Now, we can use the Spring bean defined
            above directly in a JSF page, as in the following excerpt from
            createReservation.xhtml:</para>

            <informalexample>
              <para><programlisting>&lt;rich:panel&gt;
                        &lt;f:facet name="header"&gt;Select Account&lt;/f:facet&gt;
                        &lt;h:form id="AccountSelectForm"&gt;
                            &lt;rich:extendedDataTable id="accountsTable" value="#{accountFilterCreate}" var="account"
                                                    selectionMode="single"
                                                    selection="#{accountFilterCreate.selection}"
                                                    enableContextMenu="true"
                                                    height="250px"
                                                    rows="5"&gt;
                                &lt;a4j:support event="onselectionchange"
                                             action="#{reservationCreate.updateSelectedAccount}"
                                             reRender="reservationDetails"/&gt;

                                &lt;rich:column label="Id" width="7%"&gt;
                                    &lt;f:facet name="header"&gt;
                                        &lt;h:outputText value="Id"/&gt;
                                    &lt;/f:facet&gt;
                                    &lt;h:outputText value="#{account.id}"/&gt;
                                &lt;/rich:column&gt;

                                &lt;rich:column label="First Name"&gt;
                                    &lt;f:facet name="header"&gt;
                                        &lt;h:outputText value="First Name"/&gt;
                                    &lt;/f:facet&gt;
                                    &lt;h:outputText value="#{account.subscriber.name.firstName}"/&gt;
                                &lt;/rich:column&gt;

                                &lt;rich:column label="Last Name"&gt;
                                    &lt;f:facet name="header"&gt;
                                        &lt;h:outputText value="Last Name"/&gt;
                                    &lt;/f:facet&gt;
                                    &lt;h:outputText value="#{account.subscriber.name.lastName}"/&gt;
                                &lt;/rich:column&gt;

                                &lt;rich:column label="City"&gt;
                                    &lt;f:facet name="header"&gt;
                                        &lt;h:outputText value="City"/&gt;
                                    &lt;/f:facet&gt;
                                    &lt;h:outputText value="#{account.subscriber.address.city}"/&gt;
                                &lt;/rich:column&gt;

                                &lt;rich:column label="Country"&gt;
                                    &lt;f:facet name="header"&gt;
                                        &lt;h:outputText value="Country"/&gt;
                                    &lt;/f:facet&gt;
                                    &lt;h:outputText value="#{account.subscriber.address.country}"/&gt;
                                &lt;/rich:column&gt;

                                &lt;f:facet name="footer"&gt;
                                    &lt;rich:datascroller id="scrollerAccount" for="accountsTable" maxPages="5"
                                                       page="#{accountFilterCreate.currentPage}"/&gt;
                                &lt;/f:facet&gt;
                            &lt;/rich:extendedDataTable&gt;
                        &lt;/h:form&gt;
                    &lt;/rich:panel&gt;</programlisting>All the EL variables
              that are used in the previous example, including the ones
              referenced in the Richfaces elements are, in fact, Spring beans.
              They can be used either as backing beans for retrieving and
              setting values, as well as for invoking methods corresponding to
              JSF events.</para>
            </informalexample>
          </informalexample>
        </informalexample>
      </informalexample>
    </section>

    <section>
      <title>Invoicing: Spring MVC and EJB</title>

      <para>The Invoicing application provides another example of
      interoperability between Spring and the Java EE services provided by
      JBoss. If in the previous example, the business tier was implemented
      using Spring and the web tier was using JSF, in this example the roles
      are reversed: the business tier is using EJB and the web tier is using
      Spring.</para>

      <para>The Spring MVC beans are defined in the
      /WEB-INF/spring-servlet-context.xml file, referenced by the Spring MVC
      DispatcherServlet definition that is described WEB-INF/web.xml. For this
      implementation, we have chosen the Spring 2.5 annotation-based
      configuration, and the AccountController class that implements the
      controller part of the configuration is injected with EJBs defined in
      section 3.2:</para>

      <para><informalexample>
          <para><programlisting>@Controller
public class AccountController
{

   @EJB(mappedName = "sportsclub/BillingService")
   BillingService billingService;

   @EJB(mappedName = "sportsclub/SubscriptionService")
   SubscriptionService subscriptionService;

   /* some code ommitted */

   @RequestMapping(value = "/accountDetail.do", method = RequestMethod.GET)
   ModelMap getAccountDetail(@RequestParam("id") String id)
   {
      Account account = subscriptionService.findAccountById(Long.parseLong(id));

      List&lt;Invoice&gt; invoices = billingService.getInvoices(account);

      boolean hasCurrentInvoice = false;
      Date currentDate = new Date();

      for (Invoice invoice: invoices)
      {
         if (invoice.getBillingPeriod().contains(currentDate))
         {
            hasCurrentInvoice = true;
            break;
         }
      }

      List&lt;Payment&gt; payments = billingService.getPayments(account);

      ModelMap model = new ModelMap();
      model.addAttribute(account);
      model.addAttribute("invoices", invoices);
      model.addAttribute("payments", payments);
      model.addAttribute("hasCurrentInvoice",hasCurrentInvoice);
      return model;
   }


   @RequestMapping(value = "/generateInvoice.do", method = RequestMethod.POST)
   ModelMap generateInvoice(@RequestParam("id") String id)
   {
      Account account = subscriptionService.findAccountById(Long.parseLong(id));
      Invoice invoice = billingService.generateInvoice(account);

      ModelMap model = new ModelMap();
      model.addAttribute("id",id);
      model.addAttribute(invoice);
      return model;
   }

}
</programlisting>The @Controller annotation will be detected by Spring, as it
          does a scanning of the classpath which is prompted by including the
          following line into /WEB-INF/spring-servlet-context.xml.</para>

          <informalexample>
            <para><programlisting>&lt;context:component-scan base-package="org.jboss.snowdrop.samples.sportsclub.springmvc"/&gt;
</programlisting></para>
          </informalexample>
        </informalexample></para>

      <para>As a Spring-managed object, the bean is injected with the EJBs
      BillingService and SubscriptionService, as required by annotated the
      respective fields with the @EJB annotation.</para>

      <para>The @RequestMapping-annotated methods will be executed when the
      user is accessing the specified URL and HTTP method. The request
      parameters will be bound to method arguments. In the example above,
      invoking the URL
      http://localhost:8080/sportsclub/invoicing/accountDetail.do?id=1 will
      cause the invocation accountController.getAccountDetail(1). The method
      will invoke the appropriate business services (in this case, exposed as
      EJBs) and will return a map of business object collections, indexed by
      their names. Spring MVC will take care of setting them on the request,
      so that they can be used for rendering the response.</para>

      <para>By default, Spring MVC will try to find a view whose name is
      'accountDetail', and based on the view resolver definition from
      /WEB-INF/spring-servlet-context.xml, it will use the JSP file at
      /WEB-INF/jsp/accountDetail.jsp. This JSP uses the Spring tag libraries
      for form processing, so that the collections previously returned will be
      accessible using JSTL expressions, and furthermore, we will find the
      following declaration:</para>

      <informalexample>
        <programlisting>&lt;form:form action="generateInvoice.do"&gt;
                This account does not have an invoice for the current billing period.&lt;p/&gt;
                You can create one now:
                &lt;input type="hidden" name="id" value="&lt;c:out value="${account.id}"/&gt;"&gt;
                &lt;input type="submit" value="Create invoice"/&gt;&lt;br/&gt;
            &lt;/form:form&gt;</programlisting>
      </informalexample>

      <para>Clicking the 'Create Invoice' button will result in a POST
      submission to
      http://localhost:8080/sportsclub/invoicing/generateInvoice.do?id=1 and
      the subsequent invocation of the generateInvoice method.</para>

      <para>A small note here: in order to be able to demonstrate a few
      Spring/JBoss integration features, the Invoicing application also
      contains a number of business services that are using Spring. They do
      not play any role in the Spring MVC/EJB integration, and we will discuss
      more about them in section 6.</para>
    </section>

    <section>
      <title>A problem of reusing content</title>

      <para>Having three different web applications to be included in the same
      package raises the problem of reusing some content. Surely, the images
      and stylesheets that are part of the application design can be copied in
      each individual project, but this raises the problem of maintainability.
      Therefore, most of the static content used by the Sportsclub application
      is defined in a separate web module, sportsclub-staticwebcontent, which
      is then included by Maven at build time as follows:</para>

      <para><informalexample>
          <para><programlisting>&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.snowdrop.samples.sportsclub&lt;/groupId&gt;
  &lt;artifactId&gt;sportsclub-staticwebcontent&lt;/artifactId&gt;
  &lt;version&gt;${project.version}&lt;/version&gt;
  &lt;type&gt;war&lt;/type&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</programlisting><note>
              <para>When working in an IDE this might produce an undesirable
              side-effect. If the IDE does not know how to apply Maven
              overlays correctly, the static content may not be available when
              building and deploying the application through the IDE, without
              Maven. This does not affect the general functionality of the
              application but may affect the look and feel in that particular
              situation. However, if the application is build using Maven,
              this will not be a problem.</para>
            </note></para>
        </informalexample></para>
    </section>
  </section>

  <section>
    <title>Enterprise Integration Features</title>

    <para>Apart from the Spring/JSF/EJB integration, which you have seen in
    the previous sections, the Sportsclub application suite provides a few
    other examples of integrating Spring and JBoss. Since all the features are
    Spring-based, they have been included as business services of the
    Invoicing web application. All the definitions for the following examples
    can be found in the /WEB-INF/spring-business-context.xml file defined in
    the spring-invoicing-webmvc module.</para>

    <section>
      <title>Payment processing: JMS integration through JCA</title>

      <para>Besides displaying the current status of invoices and payments for
      a given account and generating invoices through the web interface, the
      Sportsclub application can also process payments for various accounts.
      The assumption of this scenario is that the system can receive payment
      notifications asynchronously, through a JMS queue. Once such a payment
      has been received, it can be processed by a message-driven component,
      which in our case is a Spring bean. In order to take full advantage of
      the managed environment provided by the application server, the Spring
      bean will be invoked in a JCA context.</para>

      <para>The component that processes JMS messages is a POJO:</para>

      <para><informalexample>
          <para><programlisting>@Component
public class PaymentNotificationProcessor
{

   @Autowired
   private PaymentProcessor paymentProcessor;

   public void processPaymentNotification(PaymentNotification paymentNotification)
   {
      paymentProcessor.processPayment(paymentNotification.getAccountNumber(), paymentNotification.getAmount());
   }

}</programlisting></para>
        </informalexample></para>

      <para>It delegates the actual processing of a PaymentNotification to a
      different component, the PaymentProcessor, which is injected in the
      PaymentNotificationProcessor. This is done in order to maintain a degree
      of separation between the way data may be represented when exchanged
      over the messaging system (i.e. encapsulated in a PaymentNotification
      object), and the contract of the internal component which actually does
      the processing. The PaymentProcessor instance injected into the
      PaymentNotificationProcessor is, in fact, reused by the
      PaymentNotificationService web service implementation (whose contract
      does not depend on the PaymentNotification entity). </para>

      <para>Spring will instantiate a bean named
      "paymentNotificationProcessor" which will be registered as a processor
      for JMS message as follows:</para>
    </section>

    <section>
      <title>Aspects and auditing</title>

      <para>Payments must be audited. Besides keeping a record of payments
      associated with an account, we may want to set up an auditing service
      that will audit every attempt of making a payment. In the simplest case
      we can just log that information, although in a real life scenario
      things may be more sophisticated. In order to do so, we set up a
      PaymentAuditor aspect that intercepts every call made to the
      PaymentProcessor.</para>

      <para>The aspect is a simple POJO:</para>

      <para><informalexample>
          <para><programlisting>public class PaymentAuditor
{
   /* code ommitted */

   public void auditPayment(Long accountId, BigDecimal amount)
   {
     System.out.println("AUDIT ENABLED! A payment has been made to account "
                          + accountId + " for the amount of " + amount);
   }
}</programlisting></para>
        </informalexample>The aspect is applied through the following
      definitions:</para>

      <informalexample>
        <para><programlisting>   &lt;aop:config&gt;
       &lt;aop:aspect ref="paymentAuditor"&gt;
           &lt;aop:pointcut id="processingPayment" 
               expression="execution(* *..PaymentProcessor+.*(..)) &amp;amp;&amp;amp; args(accountId, amount)"/&gt;
           &lt;aop:before arg-names="accountId, amount" pointcut-ref="processingPayment" method="auditPayment"/&gt; 
       &lt;/aop:aspect&gt;
   &lt;/aop:config&gt;

   &lt;bean id="paymentAuditor" class="org.jboss.snowdrop.samples.sportsclub.audit.PaymentAuditor"/&gt; 

</programlisting>As you can see, the aspect is defined as a bean and applied
        as an aspect through the Spring aop namespace. The pointcut definition
        is an AspectJ expression.</para>
      </informalexample>
    </section>

    <section>
      <title>Configuring Spring beans through JMX</title>

      <para>JMX is a very important tool for monitoring and configuring Java
      applications. Collecting information about the system and the ability of
      making configuration at runtime are important administration features.
      For this example, the requirement is to be able to turn auditing on and
      off, at runtime, whenever required. Removing an aspect once it has been
      applied by Spring is not possible, so the solution in this case is to
      define a flag property on the aspect, which controls whether the
      auditing functionality will be invoked or not.</para>

      <para>In order to be able to make changes at runtime, the Spring bean
      which implements the aspect will be configured as a JMX bean and
      registered in the MBean server of JBoss. In this example, we are using
      annotations to define Spring-specific JMX metadata. The complete
      definition for the PaymentAuditor is:</para>

      <para><informalexample>
          <para><programlisting>@ManagedResource(objectName = "sportsclub:name=paymentAuditor", description = "Payment Auditor", logFile = "log-sportsclub-auditor-jmx.log")
@Component
public class PaymentAuditor
{
   private boolean enabled = true;

   @ManagedAttribute
   public void setEnabled(boolean enabled)
   {
      this.enabled = enabled;
   }

   @ManagedAttribute
   public boolean getEnabled()
   {
      return this.enabled;
   }

   public void auditPayment(Long accountId, BigDecimal amount)
   {
      if (this.enabled)
      {
         System.out.println("AUDIT ENABLED! A payment has been made to account " + accountId + " for the amount of " + amount);
      }
      else
      { 
         System.out.println("AUDIT DISABLED!"); 
      }
   }
}</programlisting>The annotations ManagedResource and ManagedAttribute are
          using to indicate what classes and properties are JMX-managed. In
          order to expose the bean through JMX, it must be exported using
          Spring's MBean Exporter.</para>

          <para><programlisting>&lt;bean id="attributeSource" class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;

   &lt;bean class="org.springframework.jmx.export.MBeanExporter"&gt;
       &lt;property name="autodetectModeName" value="AUTODETECT_ASSEMBLER"/&gt;
       &lt;property name="ensureUniqueRuntimeObjectNames" value="true"/&gt;
       &lt;property name="namingStrategy"&gt;
           &lt;bean class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
               &lt;property name="attributeSource" ref="attributeSource"/&gt;
           &lt;/bean&gt;
       &lt;/property&gt;
       &lt;property name="assembler"&gt;
           &lt;bean class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
               &lt;property name="attributeSource" ref="attributeSource"/&gt;
           &lt;/bean&gt;
       &lt;/property&gt;
   &lt;/bean&gt;</programlisting></para>
        </informalexample></para>

      <para>As a result, you can turn this functionality on and off directly
      from the JBoss AS JMX administration console.</para>
    </section>

    <section>
      <title>Payment processing: exposing a JAX-WS web service</title>

      <para>Another way of interacting with external applications, is by
      exposing a web service. In this scenario, payment notifications may not
      arrive only as asynchronous events on a message queue, but also as
      synchronous web service invocations. For this purpose, the application
      will expose a Spring bean with JAX-WS annotations as a web
      service.</para>

      <para>To that end, a JAX-WS annotated class is provided by the
      application:</para>

      <informalexample>
        <para><programlisting>@WebService
public class PaymentNotificationService extends SpringBeanAutowiringSupport
{

   @Autowired
   private PaymentProcessor paymentProcessor;

   @WebMethod
   public Long notifyPayment(Long accountNumber, BigDecimal amount)
   {
      return paymentProcessor.processPayment(accountNumber, amount);
   }

}</programlisting>By extending SpringBeanAutowiringSupport, the class
        PaymentNotificationService will be injected automatically with the
        same PaymentProcessor instance that is used by the JMS notification
        processor, and defined in the application context created from
        WEB-INF/spring-business-context.xml. This is necessary, because no
        bean of the type PaymentNotificationService is defined in the
        application context. Instead, the web service is defined and mapped as
        a servlet in /WEB-INF/web.xml:</para>

        <para><programlisting>&lt;servlet&gt;
       &lt;servlet-name&gt;PaymentNotificationService&lt;/servlet-name&gt;
       &lt;servlet-class&gt;org.jboss.snowdrop.samples.sportsclub.ws.PaymentNotificationService&lt;/servlet-class&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
       &lt;servlet-name&gt;PaymentNotificationService&lt;/servlet-name&gt;
       &lt;url-pattern&gt;/ws/payment&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;</programlisting>As a result, the a JAX-WS web
        service can be accessed at http://localhost:8080/ws/payment.</para>
      </informalexample>
    </section>
  </section>
</chapter>
